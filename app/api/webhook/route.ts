import { NextResponse, type NextRequest } from 'next/server';
import admin from 'firebase-admin';
import crypto from 'crypto';

// --- Firebase Admin SDK ---
if (!admin.apps.length) {
  try {
    const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT!);
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
  } catch (e) {
    console.error("Firebase Admin initialization error", e);
  }
}
const db = admin.firestore();
const STORE_ID = 'laundry_1';

// ---- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î type ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô ----
interface QuickReplyItem {
  type: string;
  action: {
    type: string;
    label: string;
    text: string;
  };
}

interface Message {
  type: string;
  text?: string;
  quickReply?: {
    items: QuickReplyItem[];
  };
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏õ‡∏∏‡πà‡∏° Quick Reply
async function replyMessage(
  replyToken: string,
  text: string,
  quickReplyItems?: QuickReplyItem[]
) {
  const replyUrl = 'https://api.line.me/v2/bot/message/reply';
  const accessToken = process.env.LINE_MESSAGING_TOKEN!;

  const messagePayload: { replyToken: string; messages: Message[] } = {
    replyToken: replyToken,
    messages: [{ type: 'text', text: text }],
  };

  if (quickReplyItems && quickReplyItems.length > 0) {
    messagePayload.messages[0].quickReply = { items: quickReplyItems };
  }

  const response = await fetch(replyUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`,
    },
    body: JSON.stringify(messagePayload),
  });
  if (!response.ok) {
    console.error("Failed to send reply message:", await response.json());
  }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á DB
async function startTimer(
  userId: string,
  storeId: string,
  machineType: 'washer' | 'dryer',
  machineId: number,
  duration: number,
  displayName: string,
  replyToken: string
) {
  const endTime = new Date(Date.now() + duration * 60 * 1000);
  const existingTimersQuery = await db.collection('stores').doc(storeId).collection('timers')
    .where('machine_id', '==', machineId)
    .where('machine_type', '==', machineType)
    .where('status', '==', 'pending')
    .get();

  if (!existingTimersQuery.empty) {
    await replyMessage(replyToken, `‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ üôè\n‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á ${displayName} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡πà‡∏∞`);
    return;
  }

  await db.collection('stores').doc(storeId).collection('timers').add({
    user_id: userId,
    machine_id: machineId,
    machine_type: machineType,
    display_name: displayName,
    duration_minutes: duration,
    end_time: endTime,
    status: 'pending',
  });

  await replyMessage(replyToken, `‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö‡∏Ñ‡πà‡∏∞! ‚úÖ\n‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ ${duration} ‡∏ô‡∏≤‡∏ó‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${displayName} ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞`);
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get('x-line-signature') || '';
    const channelSecret = process.env.LINE_MESSAGING_CHANNEL_SECRET!;
    if (!channelSecret) {
      throw new Error("LINE_MESSAGING_CHANNEL_SECRET is not set in environment variables.");
    }
    const hash = crypto.createHmac('sha256', channelSecret).update(body).digest('base64');
    if (hash !== signature) {
      throw new Error("Signature validation failed!");
    }
    const events = JSON.parse(body).events;

    for (const event of events) {
      if (event.type === 'message' && event.message.type === 'text') {
        const userId = event.source.userId;
        const userMessage = event.message.text.trim();
        const replyToken = event.replyToken;

        // ... (logic ‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)
      } else {
        if (event.replyToken) {
          await replyMessage(event.replyToken, '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
        }
      }
    }
    return NextResponse.json({ status: "ok" });
  } catch (error: unknown) {
    console.error("Error in webhook handler:", error);
    // ‡∏Å‡∏£‡∏ì‡∏µ fallback
    let fallbackReplyToken: string | undefined;
    try {
      fallbackReplyToken = (await request.json())?.events?.[0]?.replyToken;
    } catch {}
    if (fallbackReplyToken) {
      await replyMessage(fallbackReplyToken, '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
    }
    return new NextResponse("Internal Server Error", { status: 500 });
  }
}
