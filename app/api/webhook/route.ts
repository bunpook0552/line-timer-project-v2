import { NextResponse, type NextRequest } from 'next/server';
import admin from 'firebase-admin';
import crypto from 'crypto';

// --- ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Firebase Admin SDK (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏±‡∏á‡∏ö‡πâ‡∏≤‡∏ô) ---
if (!admin.apps.length) {
  try {
    const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT!);
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
  } catch (e: unknown) {
    console.error("Firebase Admin initialization error", e);
  }
}
const db = admin.firestore();
// --- ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ---

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Type ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Quick Reply Item ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á TypeScript
interface QuickReplyAction {
  type: 'message';
  label: string;
  text: string;
}

interface QuickReplyItem {
  type: 'action';
  action: QuickReplyAction;
}

// --- Type for Message Templates from Firestore ---
interface MessageTemplate {
  id: string; // The custom ID like 'initial_greeting'
  text: string;
}

// --- Global variable to store fetched messages (cached across invocations) ---
const messagesMap = new Map<string, string>();


// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å Firebase Firestore
async function fetchMessagesFromFirestore(storeId: string): Promise<void> {
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Serverless Function ‡πÉ‡∏ô Vercel, state ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÜ ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
    // ‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏≤‡∏à‡∏∞ clear map ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å request ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    if (messagesMap.size > 0 && messagesMap.get('store_id_in_cache') === storeId) {
        return; 
    }
    messagesMap.clear(); // Clear map for each request to ensure fresh messages
    messagesMap.set('store_id_in_cache', storeId); // Mark which store's messages are cached

    try {
        const templatesCol = db.collection('stores').doc(storeId).collection('message_templates');
        const snapshot = await templatesCol.get();
        if (snapshot.empty) {
            console.warn("No message templates found in Firestore. Using default fallbacks.");
            // Fallback to basic default messages if nothing found in DB
            messagesMap.set('initial_greeting', '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏£‡πâ‡∏≤‡∏ô‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö üôè\n\nüì¢ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞!');
            messagesMap.set('start_timer_confirmation', '‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö‡∏Ñ‡πà‡∏∞! ‚úÖ\n‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ {duration} ‡∏ô‡∏≤‡∏ó‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {display_name} ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_busy', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ üôè\n‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á {display_name} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_inactive', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ üôè\n‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á {display_name} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_not_found', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏£‡∏∞‡∏ö‡∏∏ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡πà‡∏∞');
            messagesMap.set('non_text_message', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
            messagesMap.set('contact_message', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡πà‡∏∞ üôè\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà:\n‡πÇ‡∏ó‡∏£: 08x-xxx-xxxx\n‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Ñ‡∏≤‡∏ô‡πå‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞');
            messagesMap.set('generic_error', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
            // Landing page texts as fallbacks
            messagesMap.set('landing_page_title', 'üß∫ Washing & Drying üß∫');
            messagesMap.set('landing_page_subtitle', '‡∏£‡πâ‡∏≤‡∏ô‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö ‡∏à‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏•‡∏ï‡∏±‡∏™‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡πå');
            messagesMap.set('landing_page_notification_header', '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡πâ‡∏≤‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à!');
            messagesMap.set('landing_page_notification_description', '‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ù‡πâ‡∏≤! ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô LINE ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ã‡∏±‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à');
            messagesMap.set('landing_page_step1_text', '‡∏™‡πÅ‡∏Å‡∏ô QR Code ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö');
            messagesMap.set('landing_page_step2_text', '‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô LINE Official Account ‡∏Ç‡∏≠‡∏á‡∏£‡πâ‡∏≤‡∏ô‡πÄ‡∏£‡∏≤');
            messagesMap.set('landing_page_step3_text', '‡∏û‡∏¥‡∏°‡∏û‡πå "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ" ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏î‡πÜ ‡πÉ‡∏ô LINE Chat ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥‡∏ï‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤');
            messagesMap.set('landing_page_button_text', '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÉ‡∏ô LINE ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô');
            messagesMap.set('landing_page_footer_note', '(‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡πà‡∏≤‡∏ô LINE Official Account ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤)');
        } else {
            snapshot.forEach(doc => {
                const data = doc.data() as MessageTemplate;
                if (data.id && data.text) {
                    messagesMap.set(data.id, data.text);
                }
            });
            console.log(`Fetched ${messagesMap.size} message templates.`);
        }
    } catch (error) {
        console.error("Error fetching message templates from Firestore:", error);
        // Ensure basic fallbacks are set even if fetch fails
        if (messagesMap.size === 0) { // Set fallbacks only if map is still empty
            messagesMap.set('initial_greeting', '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏£‡πâ‡∏≤‡∏ô‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö üôè\n\nüì¢ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞!');
            messagesMap.set('start_timer_confirmation', '‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö‡∏Ñ‡πà‡∏∞! ‚úÖ\n‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ {duration} ‡∏ô‡∏≤‡∏ó‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {display_name} ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_busy', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ üôè\n‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á {display_name} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_inactive', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ üôè\n‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á {display_name} ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡πà‡∏∞');
            messagesMap.set('machine_not_found', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏£‡∏∞‡∏ö‡∏∏ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ñ‡πà‡∏∞');
            messagesMap.set('non_text_message', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
            messagesMap.set('contact_message', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡πà‡∏∞ üôè\n\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏à‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà:\n‡πÇ‡∏ó‡∏£: 08x-xxx-xxxx\n‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Ñ‡∏≤‡∏ô‡πå‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞');
            messagesMap.set('generic_error', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
            // Add new landing page texts as fallbacks too
            messagesMap.set('landing_page_title', 'üß∫ Washing & Drying üß∫');
            messagesMap.set('landing_page_subtitle', '‡∏£‡πâ‡∏≤‡∏ô‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö ‡∏à‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏•‡∏ï‡∏±‡∏™‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡πå');
            messagesMap.set('landing_page_notification_header', '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ú‡πâ‡∏≤‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à!');
            messagesMap.set('landing_page_notification_description', '‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ù‡πâ‡∏≤! ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏ú‡πà‡∏≤‡∏ô LINE ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ã‡∏±‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à');
            messagesMap.set('landing_page_step1_text', '‡∏™‡πÅ‡∏Å‡∏ô QR Code ‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å-‡∏≠‡∏ö');
            messagesMap.set('landing_page_step2_text', '‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô LINE Official Account ‡∏Ç‡∏≠‡∏á‡∏£‡πâ‡∏≤‡∏ô‡πÄ‡∏£‡∏≤');
            messagesMap.set('landing_page_step3_text', '‡∏û‡∏¥‡∏°‡∏û‡πå "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ" ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏î‡πÜ ‡πÉ‡∏ô LINE Chat ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥‡∏ï‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤');
            messagesMap.set('landing_page_button_text', '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÉ‡∏ô LINE ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô');
            messagesMap.set('landing_page_footer_note', '(‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ú‡πà‡∏≤‡∏ô LINE Official Account ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤)');
        }
    }


    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏õ‡∏∏‡πà‡∏° Quick Reply
    async function replyMessage(replyToken: string, text: string, currentStoreLineToken: string, quickReplyItems?: QuickReplyItem[]) { // Added currentStoreLineToken
      const replyUrl = '[https://api.line.me/v2/bot/message/reply](https://api.line.me/v2/bot/message/reply)';
      const accessToken = currentStoreLineToken; // Use currentStoreLineToken here
      
      const messagePayload: {
        replyToken: string;
        messages: Array<{
          type: 'text';
          text: string;
          quickReply?: { items: QuickReplyItem[] };
        }>;
      } = {
        replyToken: replyToken,
        messages: [{ type: 'text', text: text }],
      };
      if (quickReplyItems && quickReplyItems.length > 0) {
        messagePayload.messages[0].quickReply = { items: quickReplyItems };
      }

      const response = await fetch(replyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`,
        },
        body: JSON.stringify(messagePayload),
      });
      if (!response.ok) {
        console.error("Failed to send reply message:", await response.json());
      }
    }

    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á DB
    async function startTimer(userId: string, storeId: string, machineType: 'washer' | 'dryer', machineId: number, duration: number, displayName: string, replyToken: string, currentStoreLineToken: string) { // Added currentStoreLineToken
        const endTime = new Date(Date.now() + duration * 60 * 1000);
        
        // === ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á/‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á ‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ===
        const existingTimersQuery = await db.collection('stores').doc(storeId).collection('timers')
            .where('machine_id', '==', machineId)
            .where('machine_type', '==', machineType)
            .where('status', '==', 'pending')
            .get(); 

        if (!existingTimersQuery.empty) {
            await replyMessage(replyToken, messagesMap.get('machine_busy')?.replace('{display_name}', displayName) || '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà', currentStoreLineToken); // Pass currentStoreLineToken
            return; // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ï‡πà‡∏≠ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á
        }

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á Firestore (timers sub-collection ‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ Store ID)
        await db.collection('stores').doc(storeId).collection('timers').add({
            user_id: userId,
            machine_id: machineId,
            machine_type: machineType, 
            display_name: displayName, 
            duration_minutes: duration, 
            end_time: admin.firestore.Timestamp.fromDate(endTime), // ‡πÉ‡∏ä‡πâ Timestamp.fromDate
            status: 'pending',
            created_at: admin.firestore.FieldValue.serverTimestamp(), // ‡πÄ‡∏û‡∏¥‡πà‡∏° created_at
        });

        await replyMessage(replyToken, 
            messagesMap.get('start_timer_confirmation')
            ?.replace('{duration}', String(duration))
            .replace('{display_name}', displayName) || '‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö‡∏Ñ‡πà‡∏∞! ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß', currentStoreLineToken); // Pass currentStoreLineToken
    }

    export async function POST(request: NextRequest) {
      let storeId: string | null = null; // Declare storeId here
      let channelIdFromLine: string | null = null; // Channel ID from LINE event

      try {
        // === ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å Firestore ‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ ===
        // This will be dynamic based on the LINE channel ID
        
        const body = await request.text();
        const signature = request.headers.get('x-line-signature') || '';
        const channelSecretEnv = process.env.LINE_MESSAGING_CHANNEL_SECRET!; // Renamed to avoid conflict

        if (!channelSecretEnv) {
          console.error("LINE_MESSAGING_CHANNEL_SECRET is not set.");
          throw new Error("LINE_MESSAGING_CHANNEL_SECRET is not set in environment variables.");
        }

        const hash = crypto.createHmac('sha256', channelSecretEnv).update(body).digest('base64');
        if (hash !== signature) {
          return new NextResponse("Signature validation failed!", { status: 401 });
        }

        const events = JSON.parse(body).events;
        for (const event of events) {
            if (event.source && (event.source.type === 'group' || event.source.type === 'room')) {
                console.warn("Messages from group/room chat are not supported by this bot.");
                continue; // Skip group/room messages
            }
            if (!event.source || !event.source.userId || !event.destination) { // FIX: Changed event.source.channelId to event.destination
                console.error("Invalid LINE event source or missing user ID/destination channel ID.");
                continue; // Skip events without essential source info
            }

            // === NEW: Identify store based on LINE's Channel ID ===
            channelIdFromLine = event.destination; // FIX: Changed event.source.channelId to event.destination
            const storesQuery = await db.collection('stores')
                .where('line_bot_user_id', '==', channelIdFromLine) // FIX: Changed to line_bot_user_id
                .limit(1)
                .get();

            if (storesQuery.empty) {
                console.error(`Store not found for LINE Channel ID: ${channelIdFromLine}. Please configure this LINE channel in Firebase 'stores' collection.`);
                return new NextResponse("Store not configured for this LINE channel.", { status: 404 });
            }
            const storeData = storesQuery.docs[0].data();
            storeId = storesQuery.docs[0].id; // Get the Firestore Document ID as STORE_ID
            const currentStoreLineToken = storeData.line_access_token; // Get Access Token for this store

            if (!currentStoreLineToken) {
                console.error(`LINE Access Token missing for store: ${storeId}`);
                throw new Error("LINE Access Token is missing for the identified store.");
            }

            // Fetch messages for this specific store (or use fallbacks)
            await fetchMessagesFromFirestore(storeId); // Call fetchMessagesFromFirestore here

            if (event.type === 'message' && event.message.type === 'text') {
                const userId = event.source.userId; 
                const userMessage = event.message.text.trim().toLowerCase();
                const replyToken = event.replyToken; 

                // --- DEBUG LOG START ---
                console.log("--- WEBHOOK DEBUG LOG ---");
                console.log("Received message:", userMessage);
                console.log("Identified STORE_ID:", storeId);
                // --- DEBUG LOG END ---

                // === LOGIC ‡πÉ‡∏´‡∏°‡πà: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ===
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó (‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤/‡∏≠‡∏ö‡∏ú‡πâ‡∏≤)
                if (userMessage === "‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤") {
                    const machineConfigsCol = db.collection('stores').doc(storeId).collection('machine_configs');
                    const q = machineConfigsCol.where('machine_type', '==', 'washer').where('is_active', '==', true);
                    const machineSnapshot = await q.get();
                    
                    const washerButtons: QuickReplyItem[] = machineSnapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            type: 'action',
                            action: { type: 'message', label: `‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á ${data.machine_id}`, text: `‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_${data.machine_id}` }
                        };
                    });

                    if (washerButtons.length > 0) {
                        await replyMessage(replyToken, messagesMap.get('select_washer_message') || '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤‡∏Ñ‡πà‡∏∞', currentStoreLineToken, washerButtons);
                    } else {
                        await replyMessage(replyToken, messagesMap.get('no_washer_available_message') || '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤‡∏ß‡πà‡∏≤‡∏á', currentStoreLineToken);
                    }

                } else if (userMessage === "‡∏≠‡∏ö‡∏ú‡πâ‡∏≤") {
                    const machineConfigsCol = db.collection('stores').doc(storeId).collection('machine_configs');
                    const q = machineConfigsCol.where('machine_type', '==', 'dryer').where('is_active', '==', true);
                    const machineSnapshot = await q.get();
                    
                    const dryerButtons: QuickReplyItem[] = machineSnapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            type: 'action',
                            action: { type: 'message', label: `${data.duration_minutes} ‡∏ô‡∏≤‡∏ó‡∏µ`, text: `‡∏≠‡∏ö‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_${data.machine_id}` }
                        };
                    });
                    
                    if (dryerButtons.length > 0) {
                        await replyMessage(replyToken, messagesMap.get('select_dryer_message') || '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏ö‡∏ú‡πâ‡∏≤‡∏Ñ‡πà‡∏∞', currentStoreLineToken, dryerButtons);
                    } else {
                        await replyMessage(replyToken, messagesMap.get('no_dryer_available_message') || '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏ö‡∏ú‡πâ‡∏≤‡∏ß‡πà‡∏≤‡∏á', currentStoreLineToken);
                    }
                } 
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
                else if (userMessage.startsWith("‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_")) {
                    const requestedMachineId = parseInt(userMessage.replace('‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_', ''), 10);
                    if (!isNaN(requestedMachineId)) {
                        const machineConfigsCol = db.collection('stores').doc(storeId).collection('machine_configs');
                        const q = machineConfigsCol.where('machine_id', '==', requestedMachineId).where('machine_type', '==', 'washer').limit(1);
                        const machineSnapshot = await q.get();

                        if (!machineSnapshot.empty) {
                            const machineConfigData = machineSnapshot.docs[0].data();
                            if (machineConfigData.is_active) {
                                await startTimer(userId, storeId, 'washer', machineConfigData.machine_id, machineConfigData.duration_minutes, machineConfigData.display_name, replyToken, currentStoreLineToken);
                            } else {
                                await replyMessage(replyToken, messagesMap.get('machine_inactive')?.replace('{display_name}', machineConfigData.display_name) || '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà', currentStoreLineToken);
                            }
                        } else {
                            await replyMessage(replyToken, messagesMap.get('machine_not_found') || '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å', currentStoreLineToken); 
                        }
                    } else {
                        await replyMessage(replyToken, messagesMap.get('machine_not_found') || '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', currentStoreLineToken); 
                    }
                } else if (userMessage.startsWith("‡∏≠‡∏ö‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_")) {
                    const requestedMachineId = parseInt(userMessage.replace('‡∏≠‡∏ö‡∏ú‡πâ‡∏≤_‡πÄ‡∏•‡∏∑‡∏≠‡∏Å_', ''), 10);
                    if (!isNaN(requestedMachineId)) {
                        const machineConfigsCol = db.collection('stores').doc(storeId).collection('machine_configs');
                        const q = machineConfigsCol.where('machine_id', '==', requestedMachineId).where('machine_type', '==', 'dryer').limit(1);
                        const machineSnapshot = await q.get();

                        if (!machineSnapshot.empty) {
                            const machineConfigData = machineSnapshot.docs[0].data();
                            if (machineConfigData.is_active) {
                                await startTimer(userId, storeId, 'dryer', machineConfigData.machine_id, machineConfigData.duration_minutes, machineConfigData.display_name, replyToken, currentStoreLineToken);
                            } else {
                                await replyMessage(replyToken, messagesMap.get('machine_inactive')?.replace('{display_name}', machineConfigData.display_name) || '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà', currentStoreLineToken);
                            }
                        } else {
                            await replyMessage(replyToken, messagesMap.get('machine_not_found') || '‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏ö‡∏ú‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å', currentStoreLineToken);
                        }
                    } else {
                        await replyMessage(replyToken, messagesMap.get('machine_not_found') || '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏ö‡∏ú‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', currentStoreLineToken);
                    }
                }
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 0: ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡∏Å‡∏ó‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å
                else {
                    const initialButtons: QuickReplyItem[] = [
                        { type: 'action', action: { type: 'message', label: '‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤', text: '‡∏ã‡∏±‡∏Å‡∏ú‡πâ‡∏≤' } },
                        { type: 'action', action: { type: 'message', label: '‡∏≠‡∏ö‡∏ú‡πâ‡∏≤', text: '‡∏≠‡∏ö‡∏ú‡πâ‡∏≤' } }
                    ];
                    await replyMessage(replyToken, messagesMap.get('initial_greeting') || '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡πà‡∏∞ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πà‡∏∞', currentStoreLineToken, initialButtons);
                }
            } else { // Handle non-text messages (e.g., sticker, image)
                if (event.replyToken) {
                    await replyMessage(event.replyToken, messagesMap.get('non_text_message') || '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡∏ö‡∏≠‡∏ó‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô', currentStoreLineToken);
                }
            }
        }
        return NextResponse.json({ status: "ok" });
    } catch (error: unknown) {
        console.error("Error in webhook handler:", error);
        // In case of any unexpected error, try to reply a generic message
        const fallbackReplyToken = (request.body as { events?: { replyToken?: string }[] })?.events?.[0]?.replyToken;
        // Try to get token from a static env var as fallback if store-specific token failed
        const fallbackAccessToken = process.env.LINE_MESSAGING_TOKEN; 

        if (fallbackReplyToken && fallbackAccessToken) {
            await replyMessage(fallbackReplyToken, messagesMap.get('generic_error') || '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏≤‡∏á‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á', fallbackAccessToken);
        }
        return new NextResponse("Internal Server Error", { status: 500 });
    }
}